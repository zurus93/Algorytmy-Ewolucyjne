\documentclass{article}

\usepackage{polski}
\usepackage[cp1250]{inputenc}
\usepackage{graphicx}
\usepackage{float}
\usepackage{amsmath}
\usepackage{hyperref}

\author{Monika ¯urkowska\\ Kacper Sarnacki}
\title{Specyfikacja Wstêpna\\ \textbf{Zmodyfikowany algorytm ewolucji ró¿nicowej}}
\begin{document}
\maketitle

\section{Wstêp}

Ewolucja ró¿nicowa jest stosunkowo nowym algorytmem optymalizacji numerycznej. Osobnikami s¹ $L$-wymiarowe wektory liczb rzeczywistych, w których mutacja polega na perturbacji wybranego wektora o ró¿nicê dwóch innych wektorów pomno¿on¹ przez sta³y wspó³czynnik.

Algorytm jest bardzo prosty i dzia³a bardzo dobrze na typowych funkcjach testowych. Wymaga tylko trzech parametrów:\\

\noindent
\textbf{$\mu$} - rozmiar populacji\\
\textbf{$F$} - odpowiedzialny za sterowanie mutacj¹\\
\textbf{$c_r$} - steruj¹cy krzy¿owaniem\\

\section{Pseudokod}

$P^0 = { P^0_1,P^0_2,P^0_3...P^0_{\mu}  }$\\
$t = 0$\\
$\textbf{while}$ $!stop$\\
\indent$\textbf{for}$ $i \in 1:\mu$\\
\indent\indent $P^t_j = select(P^t) $\\
\indent\indent $P^t_k,P^t_l = sample(P^t)$\\
\indent\indent $M^t_i = P^t_j + F(P^t_k-P^t_l)$\\
\indent\indent $O^t_i = crossover(P^t_i, M^t_i)$\\
\indent\indent $P^{t+1}_i = tournament(P^t_i, O^t_i)$\\
\indent $t = t + 1$\\

\section{Selekcja}

Algorytm ewolucji ró¿nicowej operuje na populacji $\mu$ osobników: $P_1, P_2, \ldots, P_\mu$, gdzie $P_i \in \mathbf{R}^L$. W ka¿dej iteracji $t$, dla ka¿dego osobnika $P_i$ z populacji liczony jest osobnik $P_j$ bêd¹cy œredni¹ wszystkich $\mu$ osobników populacji. Nastêpnie wybierane s¹ losowo osobniki $P_k$, $P_l$ takie, ¿e $i \neq l \neq k$. 


\section{Mutacja}

Wynikiem mutacji jest nowy wektor $M_i$ (zwany osobnikiem \textbf{mutantem}) otrzymany w nastêpuj¹cy sposób:

\begin{equation}
M_i = P_{j} + F * (P_{k} - P_{l})
\end{equation}

\noindent
gdzie $F \in [0,1]$ jest sta³y parametrem zwanym \textbf{wspó³czynnikiem amplifkacji} (typowa wartoœæ tego wspó³czynnika wynosi $F = 0.5$). Operacja sumy oraz ró¿nicy polega na dodaniu (odjêciu) odpowiadaj¹cych sobie sk³adowych wektorów dodawanych (odejmowanych).

\section{Krzy¿owanie}

Wynikiem krzy¿owania operuj¹cego na rodzicu $P_i$ i mutancie $M_i$ jest \textbf{osobnik próbny} $O_i$, który nastêpnie w procesie sukcesji zostanie porównany z osobnikiem $P_i$.
Ka¿dy element $O_{i,j} (j = 1, 2, \ldots, L)$, wektora $O_i$ jest wyznaczany w nastêpuj¹cy sposób:

\begin{equation}
O_{i,j} = \begin{cases}
			M_{i,j} & \text{je¿eli $rnd_j < c_r$ lub j = d}\\
			P_{i,j} & \text{w przeciwnym przypadku}\\
		  \end{cases}
\end{equation}

\noindent
gdzie $rnd_j$ jest liczb¹ losow¹ z przedzia³u [0,1) losowan¹ niezale¿nie od ka¿dego $j$. $c_r \in [0,1]$ jest sta³ym parametrem algorytmu a $d$ jest losowym numerem elementu wektora losowanego ze zbioru {1, 2, \ldots, L}.

$c_r$ oznacza prawdopodobieñstwo przejœcia elementu z wektora mutanta $M_i$ do wektora próbnego $O_i$. Dla $c_r = 1$ wszystkie elementy wektora próbnego $O_i$ pochodz¹ z mutanta $M_i$ (analogicznie dla $c_r = 0$ wszystkimi, z wyj¹tkiem jednego - warunek $j=d$ - elementami wektora $M_i$ bêd¹ elementy pochodz¹ce od rodzica $P_i$). Operator krzy¿owania "miesza" wiêc losowo elementy rodzica $P_i$ i mutanta $M_i$ daj¹c w wyniku wektor próbny $O_i$. 

Nastêpnie dopasowanie osobnika próbnego $O_i$ porównywane jest z osobnikiem rodzica $P_i$ (funkcja $tournament$). Jeœli jest ono lepsze od rodzica (czyli jego wartoœæ funkcji celu jest ni¿sza), $P_i$ zostaje zast¹pione osobnikiem próbnym, w przeciwnym przypadku osobnik $O_i$ zostaje odrzucony.

\section{Testowanie}

Powy¿szy algorytm bêdzie porównywany z klasycznym algorytmem genetycznym. Do porównania u¿yta zostanie wersja z selekcj¹ losowego osobnika (DE/rand/1/bin) oraz najlepszego w populacji (DE/best/1/bin).

Jako funkcjê celu wykorzystamy 28 funkcji benchmarka CEC-2013. Testom poddane zostan¹ klasyczne algorytmy ewolucji ró¿nicowej oraz zmodyfikowana wersja uwzglêdniaj¹ca wybór œredniej populacji w mutacji z kolejne 10, 30 i 50-wymiarowymi wektorami populacji. Ka¿dy test zostanie przeprowadzony 21 razy (dla ka¿dego wymiaru osobno). Nastêpnie dla ka¿dego algorytmu i dla ka¿dej funkcji benchmarka zostanie obliczona tabela zawieraj¹ca: najlepsze, najgorsze, œrednie oraz medianowe rozwi¹zanie a tak¿e odchylenie standardowe.\\

Algorytm zatrzyma siê po odpowiedniej iloœci iteracji - $10000*D$, gdzie $D$ jest wymiarem wektora (10, 30 i 50), b¹dŸ gdy wartoœæ b³êdu spadnie poni¿ej $10^{-8}$. Przestrzeñ przeszukiwania dla ka¿dego wymiaru znajdowaæ siê bêdzie w zakresie $[-100, 100]^D$. Pierwsza populacja generowana bêdzie losowo w przestrzeni przeszukiwania.\\

Oczekiwanym rezultatem testów jest najlepszy wynik dla algorytmu klasycznego z selekcj¹ najlepszego elementu populacji. Gorszym powinien okazaæ siê algorytm z wyborem elementu œredniego, a najgorszy z wyborem elementu losowego.

\begin{thebibliography}{9}
\bibitem{wyklad} 
\url{https://elektron.elka.pw.edu.pl/~jarabas/WAE/wyklad10.pdf}
 
\bibitem{cecopis} 
\url{https://www.rforge.net/doc/packages/cec2013/cec2013.html}
 
\bibitem{cecdokumentacja} 
\url{http://www.ntu.edu.sg/home/EPNSugan/index_files/CEC2013/Definitions\%20of\%20\%20CEC\%2013\%20benchmark\%20suite\%200117.pdf}

\bibitem{prezentacja1} 
\url{http://aragorn.pb.bialystok.pl/~wkwedlo/EA6.pdf}

\bibitem{prezentacja1} 
\url{http://www.mini.pw.edu.pl/~mandziuk/2012-01-12.pdf}
\end{thebibliography}

\end{document}
